def simple_moving_average(self, arr, window_size):
        # Verifica se o tamanho do array é maior ou igual ao tamanho da janela
        if len(arr) >= window_size:
            # Separa os arrays individuais das triplas
            z, y, x = zip(*arr)

            # Converte os arrays para float
            z = np.array(z, dtype=float)
            y = np.array(y, dtype=float)
            x = np.array(x, dtype=float)

            # Calcula a média móvel simples para cada array
            # np.convolve é usado para calcular a convolução dos arrays com uma janela de médias
            z_sma = np.convolve(z, np.ones(window_size) / window_size, mode="valid")
            y_sma = np.convolve(y, np.ones(window_size) / window_size, mode="valid")
            x_sma = np.convolve(x, np.ones(window_size) / window_size, mode="valid")

            decimal_places = 4  # Defina o número de casas decimais desejado
            z_sma = np.round(np.array(z_sma, dtype=float), decimals=decimal_places)
            y_sma = np.round(np.array(y_sma, dtype=float), decimals=decimal_places)
            x_sma = np.round(np.array(x_sma, dtype=float), decimals=decimal_places)
            # Retorna o array original concatenado com as médias móveis calculadas
            return list(zip(z_sma, y_sma, x_sma))

        # Se o tamanho do array for menor que o tamanho da janela, retorna o array original
        return arr

    def euclidean_distance(
        self, point1: Tuple[float, float, float], point2: Tuple[float, float, float]
    ) -> float:
        z1, y1, x1 = point1
        z2, y2, x2 = point2
        squared_diff_xy = (x2 - x1) ** 2 + (y2 - y1) ** 2 + (z2 - z1) ** 2
        distance_xy = np.sqrt(squared_diff_xy)
        return distance_xy

    def create_graph(
        self, moving_avg: bool = False, window_moving_avg_sz: int = 2
    ) -> None:

        non_zero_pos = []

        non_zero_voxels = np.nonzero(self.image)  # Get indices of all non-zero voxels
        for z, y, x in zip(*non_zero_voxels):
            voxel = (z, y, x)
            non_zero_pos.append(voxel)

        mov_avg = self.simple_moving_average(non_zero_pos, window_moving_avg_sz)
        #print((mov_avg))
        for voxel in mov_avg:
            neighborhood = self.euclidean_threshold_neighborhood(mov_avg, voxel, 7.5)
            for neighbor in neighborhood:
                self.add_edge_with_weight(voxel, neighbor)

            # neighborhood = self.get_26_neighborhood(voxel)

            # if moving_avg:
            #     mov_avg = self.simple_moving_average(neighborhood, window_moving_avg_sz)
            #     for neighbor in mov_avg:
            #         self.add_edge_with_weight(voxel, neighbor)
            # else:
            #     for neighbor in neighborhood:
            #         self.add_edge_with_weight(voxel, neighbor)

        print(">> Graph created")

    def euclidean_threshold_neighborhood(
        self,
        points_arr: List[Tuple[float, float, float]],
        point1: Tuple[float, float, float],
        threshold: float = 5.0,
    ) -> List[Tuple[float, float, float]]:
        
        return [point for point in points_arr if self.euclidean_distance(point, point1) <= threshold]